[{"id":"e2c1828d495adba74e80ee71a894f24e","title":"长列表低延迟组件","content":"##文档\n项目doc文档\n##github\nhttps://github.com/LJF12/VueShowcaseBox\n","slug":"长列表低延迟组件","date":"2024-08-26T00:51:24.000Z","categories_index":"","tags_index":"","author_index":"Frank Lei"},{"id":"9a664df0bc3071815213d1c94839baa2","title":"python集成flask、gunicorn、nacos（2024-2-19修订）","content":"\n集成flask框架\n依赖下载\n\n\n\n1234pip3 install flask #Flask Web 应用程序的核心框架。pip3 install Flask-MySQL #Flask 的 MySQL 数据库扩展pip3 install Flask-Script #用于将命令行脚本添加到 Flask 应用程序中的扩展pip3 install flask-sqlalchemy #SQLAlchemy数据库工具包\n\ntxt2. flask框架集成程序入口（main.py）添加flask依赖，并注册flask框架\n123456from flask import Flaskapp = Flask(__name__) # flask框架注册if __name__ == &#x27;__main__&#x27;:    app.run()\n\ntxt3. Flask Mysql集成配置flask的数据库连接配置“SQLALCHEMY_DATABASE_URI”，入参为字符串\n12345678from flask import Flaskfrom DataBase.database import DATABASE_URIapp = Flask(__name__) # flask框架注册app.config[&#x27;SQLALCHEMY_DATABASE_URI&#x27;] = DATABASE_URI  # 数据库链接if __name__ == &#x27;__main__&#x27;:    app.run()\n\n配置数据库连接DATABASE_URI 的内容,\n123456789DATABASE = &#123;    &#x27;host&#x27;: &#x27;127.0.0.1&#x27;,# 数据库服务器地址    &#x27;port&#x27;: 3306,  # 默认端口号    &#x27;user&#x27;: &#x27;xxxxx&#x27;,  # 登录用户名    &#x27;password&#x27;: &#x27;xxxxx&#x27;, # 登录密码    &#x27;database&#x27;: &#x27;dataBaseName&#x27; # 数据库名称&#125;DATABASE_URI = f&#x27;mysql+pymysql://&#123;DATABASE[&quot;user&quot;]&#125;:&#123;DATABASE[&quot;password&quot;]&#125;@&#123;DATABASE[&quot;host&quot;]&#125;:&#123;DATABASE[&quot;port&quot;]&#125;/&#123;DATABASE[&quot;database&quot;]&#125;&#x27;\n\n声明 SQLAlchemy 实例，为后续使用SQLAlchemy 工具库函数铺垫\n1234567891011from flask import Flaskfrom DataBase.database import DATABASE_URIfrom flask_sqlalchemy import SQLAlchemyapp = Flask(__name__) # flask框架注册app.config[&#x27;SQLALCHEMY_DATABASE_URI&#x27;] = DATABASE_URI  # 数据库链接db = SQLAlchemy()db.init_app(app) if __name__ == &#x27;__main__&#x27;:    app.run()\n\ntxt4. 路由声明、注册使用flask的Blueprint（蓝图）来声明路由，允许更好的项目结构和模块化，便于维护和扩展。\n123456789101112131415from flask import request, jsonify, Blueprint#声明一个蓝图，并声明蓝图的name标识tenate = Blueprint(&#x27;my_blueprint&#x27;, __name__, url_prefix=&#x27;/user&#x27;)#声明路由 定义请求方式@tenate.route(&#x27;/queryuser&#x27;, methods=[&#x27;POST&#x27;])def queryuser():    data = request.json    id = data.get(&#x27;id&#x27;)    return jsonify(&#123;&#x27;message&#x27;: &#x27;key found&#x27;, &#x27;data&#x27;: &#x27;success&#x27;&#125;), 200  @tenate.route(&#x27;/execute/&lt;id&gt;&#x27;, methods=[&#x27;GET&#x27;])def execute(id):    return &quot;helloworld&quot;;\n\n在应用程序入口注册路由\n12345678910111213from flask import Flaskfrom DataBase.database import DATABASE_URIfrom flask_sqlalchemy import SQLAlchemyfrom myApi import tenate #引入路由蓝图app = Flask(__name__) app.config[&#x27;SQLALCHEMY_DATABASE_URI&#x27;] = DATABASE_URI  db = SQLAlchemy()app.register_blueprint(tenate) # 注册路由db.init_app(app) if __name__ == &#x27;__main__&#x27;:    app.run()\n\ntxt5. 使用flask查询数据库表首先定义数据模型\n123456from datetime import datetimefrom main import db #引入的SQLAlchemy实例class myTable(db.Model):    id = db.Column(db.Integer, primary_key=True)    name = db.Column(db.String(45), nullable=True)\n\n有两种操作方式：（这里举了个最简单的例子）一、通过数据模型操作\n123456from MyTable import myTable #刚刚声明的数据模型def queryuser():    id = &#x27;1&#x27;;    newData = myTable .query.get(id) #通过数据模型查询id为1的数据    return newData;\n\n二、通过sql操作\n1234567from main import db  #引入SQLAlchemy实例from sqlalchemy import textder queryuser()    sql = text(&#x27;select id, name from tablename where id = :id&#x27;)    executeData = db.session.execute(sql,params=&#123;&#x27;id&#x27;: id&#125;).fetchone()    return executeData;\n\n\n使用gunicorn服务器启动项目默认启动flask项目是不推荐直接使用默认的web服务器的，需要通过gunicorn来作为http服务器来进行管理(应用生产环境，开发环境还是可以直接flask启动的)\n\n依赖下载\n\n\n\n1pip install gunicorn \n\ntxt2. gunicorn启动1）通过启动命令启动项目(命令中最后的app:app解释为  python模块名：实例名)\n1gunicorn -w 4 -b 0.0.0.0:8000 --daemon --access-logfile=/tmp/ass.log --log-level debug --reload app:app\n\n\n-w 或 –workers：工作进程数。Gunicorn推荐设置为(2 x $num_cores) + 1，其中$num_cores是CPU核心数。\n–worker-class：工作进程类型，默认是sync。其他选项包括gthread（线程）、eventlet和gevent等异步处理的工作模式。\n-b 或 –bind：绑定服务器的IP和端口号，例如0.0.0.0:8000。\n–daemon：以守护进程模式运行Gunicorn服务器。\n–access-logfile：访问日志文件的路径。使用-代表标准输出。\n–error-logfile：错误日志文件的路径。使用-代表标准输出。\n–log-level：日志级别，如debug、info、warning、error、critical。\n–timeout：工作进程超时秒数。超过这个时间后，工作进程将被重启。\n–reload：当代码变更时自动重载。\n\n2）上述启动过于复杂，可以将配置交给配置文件来启动项目，创建一个gunicorn.config.py文件\n1234567891011# gunicorn.conf.pyimport multiprocessingbind = &quot;0.0.0.0:8000&quot;workers = 4worker_class = &#x27;sync&#x27;loglevel = &#x27;debug&#x27;accesslog = &quot;./logs/accesslog.log&quot;errorlog = &quot;./logs/errorlog.log&quot;forwarded_allow_ips = &#x27;*&#x27;reload = True\n\n 启动项目命令为\n1gunicorn -c gunicorn.conf.py app:app\n\n\n集成nacos\n依赖下载\n\n\n\n1pip3 install nacos-sdk-python\n\ntxt2. nacos集成，注册服务程序入口（main.py）添加nacos依赖，并声明连接nacos配置以及注册服务\n12nacos_client = nacos.NacosClient(server_addresses=&#x27;xxx.xxx.xxx.xxx:8848&#x27;, namespace=&#x27;sass&#x27;,username=&#x27;nacos&#x27;, password=&#x27;nacos&#x27;)nacos_client.add_naming_instance(&#x27;leijunfeng&#x27;,  &#x27;127.0.0.1&#x27;, 8000)\n\ntxt3. 解决nacos心跳丢失问题nacos包注册服务后，没有心跳管理，需要我们显式编码，持续发送心跳，保证服务处于健康状态为在线状态，解决方案是将心跳编写在app.py的启动脚本中\n123456789def send_heartbeat_to_nacos():    # 调用send_heartbeat函数发送心跳    nacos_client.send_heartbeat(service_name=&#x27;xxxxx&#x27;,                                ip=&#x27;xxxxx&#x27;,                                port=&#x27;xxxxx&#x27;)    threading.Timer(10, send_heartbeat_to_nacos).start()#持续发送时间按照实际情况设定，尽量减少服务的内存占用# 调用发送心跳方法send_heartbeat_to_nacos()\n\n运行项目后可以看到控制台再持续输出心跳信息\n\n打包部署打包部署采用docker形式部署，可以直接把项目打入镜像中，为python web的部署方案\n\n项目结构\n\n\n\ntxt2. 设置docker镜像忽略文件 .dockerignore1234.venv   #项目的独立虚拟运行环境Dockerfile.base # 项目基础环境的dockerfileDockerfile.service # 运行项目实例的dockerfiledocker-compose.yml # docker-compose启动配置\n\ntxt3. 导出项目依赖目录12# 创建镜像时需要导出项目依赖列表pip3 freeze &gt; requirements.txt\n\ntxt4. 创建dockerfile（创建环境基础镜像）预创建完整环境的镜像，加快后续更新项目的构建速度，相应需要对基础镜像持续维护。如果基础镜像已经创建并且为最新版本，可以跳过此步骤\n123456789101112# 使用官方 Python 镜像作为基础镜像FROM python:3.9# 设置工作目录WORKDIR /app# 复制requirements.txt文件到容器内COPY requirements.txt ./# 安装依赖RUN pip install --no-cache-dir -r requirements.txt\n\n创建镜像运行命令\n1docker build -f Dockerfile.base -t fortress-ansible-base:v1.0.0 .\n\ntxt5. 创建dockerfile（运行实例镜像）创建运行的服务镜像\n123456789101112131415# 使用打好的基础镜像FROM fortress-ansible-base:v1.0.0# 设置工作目录WORKDIR /app# 将当前目录下的所有文件复制到容器中COPY . .# 暴露应用运行的端口EXPOSE 8000# 使用 Gunicorn 运行 Flask 应用# 脚本内容为 gunicorn -c gunicorn.conf.py app:appCMD [&quot;sh&quot;,&quot;docker-start.sh&quot;] \n\n创建镜像运行命令\n1docker build -f Dockerfile.app -t fortress-ansible-service:v1.0.0 . \n\ntxt6. 创建docker-compose.yml（运行）1234567version: &#x27;3&#x27;services:  web:    image: fortress-ansible-service:v1.0.0    ports:      - &quot;8000:8000&quot;\n\n\ntxt7. 运行容器docker-compose up -d\n","slug":"falsk","date":"2024-01-31T07:33:17.000Z","categories_index":"","tags_index":"python","author_index":"Frank Lei"},{"id":"f2bb811462223232905ce203d5a372bb","title":"问题记录-fegin接口调用参数有特殊符号反序列化失败导致接口400相应","content":"问题记录-fegin接口调用参数有特殊符号反序列化失败导致接口400相应\nFeign通常使用HTTP协议进行远程调用，因此在传输数据时需要进行序列化和反序列化。在Feign接口中，参数和返回类型需要被正确序列化为HTTP请求和响应的格式。\n在Feign接口参数中包含特殊字符可能导致调用接口时出现400错误的原因通常是因为特殊字符没有被正确编码。特殊字符在URL中需要进行编码，以便服务器能够正确解析它们。尝试使用URLEncoder类、Base64类对参数进行编码\n","slug":"问题记录-fegin接口调用参数有特殊符号反序列化失败导致接口400相应","date":"2023-11-28T00:56:11.000Z","categories_index":"","tags_index":"","author_index":"Frank Lei"},{"id":"d09c2e9e874afde71bf8573558487871","title":"Gmssl国密加密-JAVA集成","content":"SM加密使用GMSSL集成如何安装GMSSL库以及如何编译GMSSL-JAVA包，集成以及JAVA开发一、前置条件windows系统安装  \nCmake:https://cmake.org/download/mingW:https://www.mingw-w64.org/downloads/\n\nMac系统安装  \nCmake:https://cmake.org/download/GCC  \n\nGMSSL 3.1.1（https://github.com/guanzhi/GmSSL/releases）GMSSL-JAVA（https://github.com/GmSSL/GmSSL-Java）  \n二、安装Cmake安装包安装 然后环境变量path 引入安装目录到bin文件夹输入命令验证cmake是否安装成功  \n三、安装mingw(windows)解压包解压 然后环境变量path 引入安装目录到bin文件夹输入命令验证mingw是否安装成功mingw里面带的有gcc，查看验证是否安装成功\n四、安装GCC(Mac)得调研一下，不太清除mac怎么装  \n五、安装GMSS安装包安装 然后环境变量path 引入安装目录（Mac同理）输入gmssl version验证是否安装成功  \n六、编译GMSS-JAVA(windows)进入项目根目录，创建文件夹build进入build输入命令：    \n12cmake -G &quot;MinGW Makefiles&quot; ..mingw32-make\n获取到jar包以及libgmssljni\n七、编译GMSS-JAVA（Mac）进入项目根目录，创建文件夹build\n进入build输入命令：\n12cmake ..make\n获取到jar包以及libgmssljni(mac获取到的应该是..dylib后缀的库)\n八、Centos安装GMSSL&amp;GMSSL-JAVA还是安装好前置条件cmakemakegccyum install cmakeyum install makeyum install gcc验证安装是否成功\n1cmake --version、make --version、gcc --version\n下载源码上传至服务器安装GMSSL进入GMSSL根目录创建build文件夹并进入build文件夹\n12mkdir buildcd build\n执行命令构建系统所需的 Makefile 或其他构建文件\n1cmake ..\n执行命令编译\n12makemake test\n安装GMSSL\n1sudo make install\n验证是否安装成功\n1gmssl -version\n编译GMSSL-JAVA进入GMSSL根目录创建build文件夹并进入build文件夹  \n12mkdir buildcd build\n执行命令构建系统所需的 Makefile 或其他构建文件  \n1cmake ..\n执行命令编译\n12makemake test\n获得jar包和so库\n","slug":"Gmssl国密加密-JAVA集成","date":"2023-11-13T06:34:45.000Z","categories_index":"","tags_index":"","author_index":"Frank Lei"},{"id":"023ebc623e8a95d05a2f04c1b4ad62d5","title":"接口调度模拟开发","content":"##文档\n项目doc文档\n##github\nhttps://github.com/LJF12/LFCX-API-Manager\n","slug":"接口调度模拟开发","date":"2023-07-13T05:50:56.000Z","categories_index":"","tags_index":"VUE","author_index":"Frank Lei"},{"id":"8efdfe4872c447599d42e0a8f10aa3e3","title":"Hexo搭建博客","content":"Hexo搭建博客环境需要gitHubnode\n","slug":"Hexo搭建博客","date":"2021-12-31T17:13:40.000Z","categories_index":"","tags_index":"hexo","author_index":"Frank Lei"}]